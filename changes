#!/usr/bin/env python3

import argparse
import collections
import copy
import enum
import logging
import re
import subprocess


class Version(object):

    def __init__(self, major=0, minor=0, patch=0):
        self.major = major
        self.minor = minor
        self.patch = patch
        self.did_update_major = False
        self.did_update_minor = False
        self.did_update_patch = False

    def bump_major(self):
        if self.did_update_major:
            return
        self.major = self.major + 1
        self.minor = 0
        self.patch = 0
        self.did_update_major = True

    def bump_minor(self):
        if self.did_update_minor or self.did_update_major:
            return
        self.minor = self.minor + 1
        self.patch = 0
        self.did_update_minor = True

    def bump_patch(self):
        if self.did_update_patch or self.did_update_minor or self.did_update_major:
            return
        self.patch = self.patch + 1
        self.did_update_patch = True

    def __str__(self):
        return f"{self.major}.{self.minor}.{self.patch}"


def run(command):
    result = subprocess.check_output(command, stderr=subprocess.PIPE)
    lines = result.decode("utf-8").strip().split("\n")
    return lines


def commits(ref):
    return run(["git", "log", "--pretty=format:%H", ref])


def get_tags(sha):
    try:
        return run(["git", "describe", "--tags", "--exact-match", sha])
    except subprocess.CalledProcessError:
        return []


def parse_version(tag, scope=None):
    prefix = ""
    if scope is not None:
        prefix = scope + "_"
    sv_parser = re.compile(r"^" + prefix + r"(\d+).(\d+).(\d+)$")
    match = sv_parser.match(tag)
    if match:
        return Version(major=int(match.group(1)),
                       minor=int(match.group(2)),
                       patch=int(match.group(3)))
    raise ValueError("Not a version")


class Commit(object):

    def __init__(self, sha, message, tags, version):
        self.sha = sha
        self.message = message
        self.tags = tags
        self.version = version


class Type(enum.Enum):
    FEATURE = "feat"
    FIX = "fix"
    BREAKING_CHANGE = "BREAKING CHANGE"
    UNKNOWN = "UNKNOWN"


def version_from_tags(tags, scope=None):
    for tag in tags:
        try:
            return parse_version(tag, scope)
        except ValueError:
            pass
    return None


def get_commits(ref, scope=None, stop=lambda x: False):
    results = []
    commits = run(["git", "log", "--pretty=format:%H:%s", ref])
    for c in commits:
        sha, message = c.split(":", 1)
        commit = Commit(sha, parse_message(message), get_tags(sha), version_from_tags(get_tags(sha), scope))
        results.append(commit)
        if stop(commit):
            return results
    return results


OPERATIONS = {
    Type.BREAKING_CHANGE: lambda commit, version: version.bump_major(),
    Type.FEATURE: lambda commit, version: version.bump_minor(),
    Type.FIX: lambda commit, version: version.bump_patch(),
    Type.UNKNOWN: lambda commit, version: logging.warning("Ignoring '%s'...", commit.message.description),
}


class Message(object):

    def __init__(self, type, scope, description):
        self.type = type
        self.scope = scope
        self.description = description


def parse_message(message):
    cc_parser = re.compile(r"^(.+?)(\((.+?)\))?:(.+)$")
    match = cc_parser.match(message)
    if match is not None:
        (cc_type, cc_scope, cc_description) = (match.group(1), match.group(3), match.group(4))
        try:
            return Message(type=Type(cc_type),
                           scope=cc_scope,
                           description=cc_description.strip())
        except ValueError:
            pass
    return Message(type=Type.UNKNOWN,
                   scope=None,
                   description=message.strip())


TYPE_TO_SECTION = {
    Type.BREAKING_CHANGE: "Changes",
    Type.FEATURE: "Changes",
    Type.FIX: "Fixes",
    Type.UNKNOWN: "Ignore",
}


def format_messages(messages, section):
    result = ""
    result = result + f"**{section}**\n\n"
    for message in messages:
        result = result + f"- {message.description}"
        if message.scope is not None:
            result = result + f" ({message.scope})"
        result = result + "\n"
    result = result + "\n"
    return result


def format_changes(changes):
    result = ""
    sections = collections.defaultdict(list)
    for commit in changes:
        sections[TYPE_TO_SECTION[commit.message.type]].append(commit.message)
    if "Changes" in sections:
        result = result + format_messages(sections["Changes"], "Changes")
    if "Fixes" in sections:
        result = result + format_messages(sections["Fixes"], "Fixes")
    return result


def format_release(release):
    result = f"# {release.version}"
    if not release.has_tag:
        result = result + " (Unreleased)"
    result = result + "\n\n"
    result = result + format_changes(release.changes)
    return result


def format_releases(releases):
    result = ""
    for release in releases:
        result = result + format_release(release)
    return result


class Release(object):

    def __init__(self, version, changes):
        self.version = version
        self.changes = changes
        self.has_tag = False  # TODO: Rename this to 'unreleased'

    def set_previous_version(self, previous_version):
        """Recomputes the current version based on the previous version by applying the changes in order."""
        self.version = copy.deepcopy(previous_version)
        for commit in reversed(self.changes):
            if commit.message.type in OPERATIONS:
                OPERATIONS[commit.message.type](commit, self.version)
            else:
                logging.warning("Ignoring unknown commit: '%s'", commit.message.description)

    @property
    def is_empty(self):
        return len(self.changes) < 1


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("command", choices=["current-version", "current-changes", "tagged-version", "tag"])
    parser.add_argument("--scope", help="scope to be used in tags and commit messages")
    options = parser.parse_args()

    all_changes = get_commits("main", scope=options.scope)

    releases = []
    releases.append(Release(None, []))
    for change in all_changes:
        if change.version is not None:
            release = Release(change.version, [])
            release.has_tag = True
            releases.append(release)
        releases[-1].changes.append(change)

    # Fix-up the version number for any un-released current release.
    if releases[0].version is None:
        releases[0].set_previous_version(releases[1].version if len(releases) > 1 else Version(0, 1, 0))

    # Remove the empty head release if there's already an active release.
    if len(releases) > 1 and releases[0].is_empty:
        releases.pop(0)


    # Run the requested command.
    if options.command == "current-version":
        print(releases[0].version)
    elif options.command =="current-changes":
        markdown = format_changes(changes)
        print(markdown)
    elif options.command == "tagged-version":
        print(initial_version)
    elif options.command == "tag":
        # TODO: This should allow the --release-candidate flag and auto-increment release candidates.
        tag = str(version)
        if options.scope is not None:
            tag = f"{options.scope}_{tag}"
        run(["git", "tag", str(version)])

    # print(format_releases(releases))

    exit()

    # Get all the commits up to and including the most recent commit tagged with a version.
    changes = get_commits("main", scope=options.scope, stop=lambda x: x.version is not None)
    changes.reverse()

    # Determine the starting version by checking to see if the first commit has a version tag.
    # If it does, update the version and discard the first tag as we assume any change it describes is already captured
    # in that version.
    initial_version = Version()
    first_commit = changes[0]
    if first_commit.version is not None:
        initial_version = first_commit.version
        changes = changes[1:]
    version = copy.deepcopy(initial_version)

    logging.debug(f"{version} (current release)")

    # Walk the commits to determine the next version.
    for commit in changes:
        if commit.message.type in OPERATIONS:
            OPERATIONS[commit.message.type](commit, version)
        else:
            logging.warning("Ignoring unknown commit: '%s'", commit.message.description)

    # Output the relevant information.
    if options.command == "current-version":
        print(version)
    elif options.command =="current-changes":
        markdown = format_changes(changes)
        print(markdown)
    elif options.command == "tagged-version":
        print(initial_version)
    elif options.command == "tag":
        # TODO: This should allow the --release-candidate flag and auto-increment release candidates.
        tag = str(version)
        if options.scope is not None:
            tag = f"{options.scope}_{tag}"
        run(["git", "tag", str(version)])


if __name__ == "__main__":
    main()



# TODO: Both current changes and current version should be able to show the 'previous' if current matches previous.